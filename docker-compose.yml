services:

  # Python backend container
  python_service:
    container_name: container-python
    networks:
      - default
    # Do NOT fall back to building from scratch if image does not exist
    # ^ might revert, but compose will only use prod for now - avoid mixing with dev
    image: dsci-cap-img-python-prod:latest
    volumes:
      - ./pyproject.toml:/pipeline/pyproject.toml:ro   # change settings locally = applied instantly with no rebuild
    ports:
      - "${PYTHON_PORT}:${PYTHON_PORT}"

  # Blazor server container, exposes port for HTTP and REST
  blazor_service:
    container_name: container-blazor
    networks:
      - default
    restart: unless-stopped
    # Do NOT fall back to building from scratch if image does not exist
    # ^ might revert, but compose will only use prod for now - avoid mixing with dev
    image: dsci-cap-img-blazor-prod:latest
    environment:
      - DOTNET_ENVIRONMENT=Docker
    ports:
      - "${BLAZOR_PORT}:${BLAZOR_PORT}"


  qeval_worker:
    container_name: container-qeval
    networks:
      - default
    restart: unless-stopped
    # Do NOT fall back to building from scratch if image does not exist
    # ^ might revert, but compose will only use prod for now - avoid mixing with dev
    image: dsci-cap-img-questeval-prod:latest
    command: python -m src.flasks --task questeval
    ports:
      - "${QUESTEVAL_PORT}:${QUESTEVAL_PORT}"

  bscore_worker:
    container_name: container-bscore
    networks:
      - default
    restart: unless-stopped
    # Do NOT fall back to building from scratch if image does not exist
    # ^ might revert, but compose will only use prod for now - avoid mixing with dev
    image: dsci-cap-img-bookscore-prod:latest
    command: python -m src.flasks --task bookscore
    ports:
      - "${BOOKSCORE_PORT}:${BOOKSCORE_PORT}"





  # Meta-service to orchestrate all DB containers at once
  databases_service:
    container_name: container-databases
    image: alpine   # extremely small OS
    command: ["sleep", "infinity"]
    depends_on:
      - mysql_service
      - postgres_service  # redundant with mysql but no downside - use makefile to launch only one
      - mongo_service
      - neo4j_service
      

  # MySQL container, volume persists data, port optional
  mysql_service:
    container_name: container-mysql
    networks:      # DB containers will listen on this hostname for convenient access
      default:     # attach to our docker network
        aliases:   # does not replace service_name
          - databases_service
    image: mysql:8
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_PASSWORD}  # not typically used, but required by MySQL installation
      - MYSQL_DATABASE=${DB_NAME}
      - MYSQL_USER=${MYSQL_USERNAME}  # problem: cannot be root
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql   # named volume for persistent DB data
      - ./docker/db-init/init_mysql.sh:/docker-entrypoint-initdb.d/init_mysql.sh:ro  # bind mount for init script
    ports:
      - "${MYSQL_PORT}:${MYSQL_PORT}"

  # Postgres container, volume persists data, port optional
  postgres_service:
    container_name: container-postgres
    networks:      # DB containers will listen on this hostname for convenient access
      default:     # attach to our docker network
        aliases:   # does not replace service_name
          - databases_service
    image: postgres:15
    environment:
      - POSTGRES_USER=${POSTGRES_USERNAME}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data   # named volume for persistent DB data
      - ./docker/db-init/init_postgres.sh:/docker-entrypoint-initdb.d/init_postgres.sh:ro  # bind mount for init script
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"

  # MongoDB container, volume persists data, port optional
  mongo_service:
    container_name: container-mongo
    networks:      # DB containers will listen on this hostname for convenient access
      default:     # attach to our docker network
        aliases:   # does not replace service_name
          - databases_service
    image: mongo:6
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
      - MONGO_INITDB_DATABASE=${DB_NAME}
    volumes:
      - mongo_data:/data/db   # named volume for persistent DB data
      - ./docker/db-init/init_mongo.sh:/docker-entrypoint-initdb.d/init_mongo.sh:ro  # bind mount for init script
    ports:
      - "${MONGO_PORT}:${MONGO_PORT}"
    command: ["--quiet"]   # clean docker logs, but still very messy / unreadable

  # Neo4j container, exposes HTTP and Bolt ports for UI and app connections
  neo4j_service:
    container_name: container-neo4j
    networks:      # DB containers will listen on this hostname for convenient access
      default:     # attach to our docker network
        aliases:   # does not replace service_name
          - databases_service
    image: neo4j:2025.09
    volumes:
      - neo4j_data:/data
      - ./docker/db-init/init_neo4j.sh:/init_neo4j.sh
    environment:
      - NEO4J_dbms_connector_http_listen__address=0.0.0.0:7474  # Init script manually writes this
    ports:
      - "0.0.0.0:${NEO4J_HTTP_PORT}:${NEO4J_HTTP_PORT}"   # HTTP web UI  - http://localhost:7474  - graph viewer
      - "0.0.0.0:${NEO4J_PORT}:${NEO4J_PORT}"   # Bolt protocol for queries
    entrypoint: ["/bin/sh", "/init_neo4j.sh"]    # Change entrypoint to init script (note: env values no longer propagate to neo4j automatically)
    command: ["${NEO4J_USERNAME}", "${NEO4J_PASSWORD}", "${NEO4J_PORT}", "${NEO4J_HTTP_PORT}"]   # Provide .env credentials as args to the init script


volumes:
  mysql_data:
  postgres_data:
  mongo_data:
  neo4j_data:


networks:  # declare our docker network globally
  default:
    name: capstone_default    # otherwise docker will auto-generate the name as "<parent_folder> + _default"