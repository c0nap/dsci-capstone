
Data Science Capstone - Patrick Conan
---

## Database Selection

**MongoDB** and **Neo4j** are strictly required for this project, but you can choose between MySQL or PostgreSQL for your required relational database.

We suggest using **PostgreSQL** for its increased security. MySQL is supported too, but its permissions model makes it unsafe for production environments.

Our code creates and drops arbitrary databases at runtime. For MySQL to work, the Docker initialization script `/db/init_mysql.sh` grants full privileges to our secondary user, which allows dropping existing databases, or even databases created by an elevated user like `root`. Postgres uses an ownership-based permission model to prevent access.


## Database Setup

If you need help installing your databases, follow these guides (click to expand).

<details>
  <summary><h3>PostgreSQL</h3></summary>
  

  1. Install database engine.
```bash
sudo apt install postgresql
```
```bash
sudo -i -u postgres
psql
CREATE USER yourusername WITH PASSWORD 'yourpassword';
ALTER USER yourusername CREATEDB;
```
```bash

```

2. Start the database service.
```bash
sudo service mysql start
```
</details>


<details>
  <summary><h3>Neo4j</h3></summary>
  
### Neo4j Installation for WSL (Ubuntu)

1. Install prerequisites `wget`, `gnupg`, and `apt-transport-https`

Without these, you can’t fetch and trust Neo4j’s signing key or add an HTTPS repo.

```bash
sudo apt install -y wget gnupg apt-transport-https
```

2. Add the GPG key

Apt refuses to install packages from unknown sources. The GPG key tells apt to trust packages signed by Neo4j.

```bash
wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/neo4j-archive-keyring.gpg
```

3. Add the Neo4j repository

By default, Ubuntu only knows about Canonical’s repos. Adding the Neo4j repo is like specifying which warehouse has the Neo4j software. Without it, apt won’t find the `neo4j` package.

```bash
echo "deb [signed-by=/usr/share/keyrings/neo4j-archive-keyring.gpg] https://debian.neo4j.com stable 5" | sudo tee /etc/apt/sources.list.d/neo4j.list
```

4. Run `apt update` after adding the repo

This refreshes apt’s index. Until you do, apt has no idea that Neo4j packages exist.

```bash
sudo apt update
```

5. Install Neo4j

Now apt knows where to find the package and can verify its signature.

```bash
sudo apt install -y neo4j
```

### First-time setup

1. Start the database service. Ignore the message that Neo4j is running on port 7474 instead of 7687 - it runs on both.

```bash
sudo service neo4j start
```

2. Log in with default username and password. `cypher-shell` is installed with `neo4j`.

```bash
cypher-shell -u neo4j -p neo4j
```

3. Prompted to change password on first login (8+ chars long). Use `:exit` to return to WSL terminal.

4. Verify number of nodes and edges generated by src.main:

```cql
MATCH (n) RETURN count(n);
MATCH ()-[r]->() RETURN count(r);
```

</details>

<details>
  <summary><h3>Blazor App with Neo4j</h3></summary>
  
#### After following the Neo4j setup guide:

5. Allow external connections to database (e.g. web app)

```bash
sudo nano /etc/neo4j/neo4j.conf
```
Uncomment line `server.default_listen_address=0.0.0.0`


6. Find local IP (inet) of your WSL shell. Dynamic IP so may change on restart.

```bash
ip addr show eth0
```

7. Test connection from Windows PowerShell. Successful if screen goes blank.

```bash
telnet <ip> 7687
```

8. To allow HTTP requests from WSL to reach Blazor app, find local IP from PowerShell with `ipconfig`, and test the connection from WSL using `curl http://<local_ip>:5055/metrics`. In Blazor, listening for all IPs is generally unsafe, so Windows Firewall may try to block it. Allowing only on Private networks is fine. If you press Cancel accidentally and need to reverse it, open Windows Firewall -> Inbound Rules, and allow BlazorApp.

</details>

<details>
  <summary><h3>Blazor App with MongoDB</h3></summary>
  
TODO
</details>

<details>
  <summary><h3>Blazor App with Postgres</h3></summary>
  
TODO
</details>





---

## Common Issues

### MySQL

External connections have different permissions than local connections. So if you sign in as `root` (via `mysql -u root -p` or `docker exec`) you'll normally have full access, but connecting externally (using a non-localhost connection string) will restrict permissions, even as root! 

As a workaround, you must allow external connections when running MySQL on local machine. Our init script does this automatically when using Docker.
```sql
-- Allow root from all IPs (not secure):
CREATE USER 'root'@'%' IDENTIFIED BY 'your_root_password';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;
```

If you want to use an existing MySQL installation and login as root, nothing will prevent you from doing so. However, we recommend creating a secondary user with appropriate permissions.


### PostgreSQL

Postgres is case-sensitive, but is inconsistent about automatic lowercasing. For example, it will convert all database names to lowercase before storing them, but will NOT auto-lowercase when requesting a specific table.

For example, `CREATE TABLE ExamTable ...` will internally create a table called `examtable`, and running `SELECT * FROM ExamTable` will fail.

For this reason, we recommend keeping `DB_NAME` lowercase in your .env file, but our logic in `get_dataframe` should be able to handle this.

### SQL Query Files
- For Docker compatibility, all database query files should have UNIX line endings (especially `.sql`).
- Keep in mind MySQL and PostgreSQL have slightly different syntax - you will need a version-specific query to create tables.
- Our PyTests use single quotes inside queries to avoid parsing issues.


## Makefile Commands

#### db-start-local
Start only the `localhost` databases specified in `.env`
```bash
make db-start-local
```

#### docker-all-dbs
Start one of each database type according to `.env` specification
```bash
make docker-all-dbs
```

## Hostname Resolution

For a comprehensive guide on how to configure your `.env` values to work across Docker containers, please use our Hostname Reference Table in the [Docker Guide](docs/docker_setup.md).



## Network Security

### Overview

Since this project contains components running on different systems, we generally allow databases to listen for ANY incoming connection to their port (all network interfaces _i.e._ 0.0.0.0). As seen above, Neo4j on WSL must listen on 0.0.0.0 to accept queries from our Blazor app running on Windows.

This problem will spread as we scale in future versions; a remote Blazor server could run on a different machine & different network, and still want access to our local Neo4j installation.

### Risks

- Modern private Wi-Fi routers use NAT by default: all incoming connections from external hosts will be rejected, unless we explicitly port-forward. Public networks (e.g. McDonalds free wifi) may not do this.

- If an attacker knows your public IP address, your computer may be exposed on your network, allowing free access to send commands through any open ports.

- Windows firewall will block external connections but only for services running on Windows. WSL and Docker containers do not have this same level of protection.

- Database credentials may feel inconsequential, but short or common passwords are very easy to brute-force.

- When an attacker gains access to a service running on your machine with elevated permissions, there are usually ways to compromise the host system - stealing sensitive data from Windows, installing external malware, or deleting your files.

### Our Unsafe Practices

- Some native WSL databases are configured to listen on 0.0.0.0 (Neo4j).

- Some docker containers will not function unless configured to listen on 0.0.0.0 (MySQL, PostgreSQL, Neo4j, MongoDB).

- When running databases with Docker Compose, databases sometimes block superuser permissions if their connection is external, even if their credentials are correct. Our Makefile elevates `root@'%'` (the remote root user) to address this.

### Precautions & Mitigation

1. Use unique, long, random passwords and avoid default usernames.

2. Run the main pipeline from a secure, private network - so home, school, or work.

3. Do not leave database services running on the background when unused, and consider rotating credentials.

4. Avoid everyday use of superuser accounts (`root`, `postgres`, `neo4j`), even if your existing database installation is configured this way. Create a dedicated user for the app and grant only the permissions it needs.

5. Optionally check `docker-compose.yml` and `Makefile` for `0.0.0.0` and remove them. It may still work depending on your configuration.

6. Instead of allowing full access to out-of-network machines, use a VPN to connect with the secured network remotely.


